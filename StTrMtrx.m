% *************************************************************************
% * Функция для расчета переходной матрицы состояния дискретной системы   *
% *************************************************************************

% A - матрица состояния непрерывной системы (постоянная или трехмерная)
% Матрица A должна быть либо постоянной - для стационарных систем,
% либо задана слоями с шагом Ts по времени - для нестационарных систем, где
% Ts - шаг дискретизации

function Phi = StTrMtrx(A,Ts,varargin)
minargs = 2;        % Минимальное количество агрументов функции
maxargs = 3;        % Максимальное количество агрументов функции
narginchk(minargs, maxargs);    % Проверка количества входных параметров

if nargin == 2
    options = odeset('RelTol',1e-3,'AbsTol',1e-6);  % Точность по умолчанию
elseif nargin == 3
    options = varargin{1};                          % Пользовательская точность
end

if size(A,1) == size(A,2)
    n = size(A,1);  % Параметр размерности системы
else
    error('Матрица состояния системы должна быть квадратной');
end
if size(A,3) == 1
    % Вариант когда А стационарна (A(t) = const)
    Phi = expm(A*Ts);
else
    % Вариант когда A нестационарна (A(t) = F(t))
    Phi = zeros(size(A));
    Phi(:,:,1) = eye(n);
    parfor k = 1:(size(A,3)-1)
        F = A(:,:,k:k+1);           %#ok<PFBNS> % F - два соседних слоя матрицы А: A(k) и A(k+1)
        [~,ksi] = SolveEq1(F,Ts,options);
        Phi(:,:,k+1) = reshape(ksi(end,:),n,n);
    end
end

%% Функция решения дифференциального уравнения dksi/dt = TET(t)*ksi
function [T,KSI] = SolveEq1(F,Ts,options)
n = size(F,1);                                  % Параметр размерности матрицы F
IC = reshape(eye(n),[],1);                      % Вектор начальных условий
[T,KSI] = ode45(@(t,ksi) Eq1(t,ksi,Ts,F), [0,Ts], IC, options);

%% Функция для формирования дифференциального уравнения dksi/dt = TET(t)*ksi
function dksi = Eq1(t,ksi,Ts,F)
% Eq1(t,ksi,Ts,F) - функция для формирования дифференциального уравнения:
% dФ(t,tau)/dt = F(t)*Ф(t,tau) в векторном виде dksi/dt = TET(t)*ksi
A = (F(:,:,2)-F(:,:,1))*t/Ts + F(:,:,1);        % Линейная интерполяция матрицы А на интервале [Ts*k,Ts*(k+1)]
TET = zeros(size(A,1)*size(A));
for k = 1:size(A,1)                             % Цикл формирования матрицы TET(t)
    n = (k-1)*size(A,1) + 1;
    TET(n:k*size(A,1),n:k*size(A,2)) = A;
end
% Уравнение dksi/dt = TET(t)*ksi
dksi = TET*ksi;